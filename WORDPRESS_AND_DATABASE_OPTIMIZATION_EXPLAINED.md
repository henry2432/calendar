# WordPress 核心優化 & 數據庫優化 詳細解釋

## 📊 完整優化路線圖

```
當前狀況：2.3-2.8 秒
         ↓
代碼級 + 伺服器級優化（已完成）
         ↓
預計：2.0-2.5 秒
         ↓
若不足，執行 WordPress 核心優化
         ↓
預計：1.8-2.3 秒
         ↓
若仍不足，執行數據庫優化
         ↓
目標：1.3-1.8 秒 ✅
```

---

## 第 1 階段：WordPress 核心優化

### 1️⃣ AUTOSAVE_INTERVAL 優化

**當前情況：**
```php
默認值：60 秒
含義：WordPress 每 60 秒自動保存一次文章草稿
```

**問題分析：**
```
每 60 秒 → 
  1. 觸發 wp_cron 鉤子
  2. 執行 wp_update_autosave()
  3. 向資料庫寫入 postmeta
  4. 清除 postmeta 快取
  5. 通知前端更新
     
累積：每分鐘 1 次資料庫寫入 + 2-3 次查詢
全天：1440 次不必要的資料庫操作
```

**優化方案：**
```php
define( 'AUTOSAVE_INTERVAL', 300 );
新值：300 秒 = 5 分鐘
含義：改為每 5 分鐘自動保存一次
```

**改善效果：**
```
減少自動保存次數：從每分鐘 1 次 → 每 5 分鐘 1 次
減少資料庫寫入：-80%
全天減少操作：1440 → 288 次（節省 1152 次操作）
頁面加載改善：-30-100ms
   - 減少背景自動保存干擾
   - 減少資料庫連接占用
   - 前端 AJAX 響應更快
```

**用戶影響：**
```
✅ 正面：
   - 頁面加載快 30-100ms
   - 資料庫負載減少 80%
   - 服務器壓力降低

⚠️ 負面：
   - 文章編輯時自動保存間隔變長（但仍可手動保存）
   - 若伺服器宕機，最多損失 5 分鐘編輯內容（而不是 1 分鐘）
   
💡 建議：對訪客沒有影響，只影響後台編輯體驗
```

---

### 2️⃣ WP_POST_REVISIONS 優化

**當前情況：**
```php
默認值：-1（無限制）
含義：保留文章的所有修訂版本
```

**問題分析：**
```
每次保存文章 →
  1. 創建新的 revision post（新行）
  2. 複製所有 postmeta（元數據）
  3. 複製所有 post content
  4. 創建新的 postmeta 記錄
  
例：編輯 100 次的文章 →
  - wp_posts 表增加 100 條 revision 記錄
  - wp_postmeta 表增加 500+ 條 revision meta 記錄
  - 數據庫每次查詢都需要排除 revision
  
全站影響：
  - 文章表查詢變慢（數據量增加）
  - postmeta 查詢變慢（垃圾數據堆積）
  - 數據庫備份時間增長
```

**優化方案：**
```php
define( 'WP_POST_REVISIONS', 3 );
新值：3
含義：只保留最近 3 個修訂版本
```

**改善效果：**
```
減少修訂版本：如果原有 100+ 版本 → 保留 3 版本
數據庫行數減少：-95%
postmeta 表清理：-90%
查詢性能改善：-20-50ms
   - 同樣查詢，數據集更小
   - 索引掃描更快
   - 內存占用更少
```

**用戶影響：**
```
✅ 正面：
   - 頁面加載快 20-50ms
   - 文章編輯頁面快 30-100ms
   - 恢復舊版本仍可行（保留 3 版本）

⚠️ 負面：
   - 只能恢復最近 3 個版本（不是完整歷史）
   - 若需要舊版本，已被永久刪除
   
💡 建議：對大多數用戶足夠，3 個版本涵蓋最近幾天的編輯
```

---

### 3️⃣ EMPTY_TRASH_DAYS 優化

**當前情況：**
```php
默認值：30
含義：垃圾桶中的項目保留 30 天後自動刪除
```

**問題分析：**
```
刪除文章時 →
  1. 標記為 post_status='trash'（不刪除）
  2. 保留所有 postmeta（查詢時需排除）
  3. 保留所有 post content（占用磁盤）
  4. 每次查詢都要檢查 post_status 並排除

30 天後自動刪除 →
  1. 觸發 wp_scheduled_delete() 鉤子
  2. 掃描所有垃圾項目（可能很多）
  3. 逐個刪除（可能很慢）
  4. 導致頁面加載卡頓

實際影響：
  - 資料庫垃圾積累
  - 查詢性能下降
  - 自動刪除時頁面慢
```

**優化方案：**
```php
define( 'EMPTY_TRASH_DAYS', 0 );
新值：0
含義：立即永久刪除，不保留垃圾桶
```

**改善效果：**
```
垃圾數據積累：-100%
定時清理任務：移除
資料庫查詢優化：-10-30ms
   - 不需檢查垃圾狀態
   - 不需掃描垃圾項目
   - 背景任務減少
```

**用戶影響：**
```
✅ 正面：
   - 刪除項目立即消失
   - 無垃圾桶相關查詢
   - 頁面加載快 10-30ms

⚠️ 負面：
   - 刪除後無法恢復（非常危險！）
   - 誤刪無法找回
   
💡 建議：此優化風險較高，僅推薦低風險操作
        可改為 define( 'EMPTY_TRASH_DAYS', 7 );（1 週清理）
```

---

## 第 2 階段：數據庫優化

### 1️⃣ 添加缺失的索引

**為什麼需要索引？**

```
示例查詢：
SELECT * FROM wp_postmeta WHERE post_id = 123 AND meta_key = '_price'

沒有索引的情況：
  掃描 postmeta 表的每一行（可能 100,000+ 行）
  檢查 post_id 是否 = 123（耗時 100-500ms）
  檢查 meta_key 是否 = '_price'

有索引的情況：
  直接跳到索引中 post_id=123 的部分（<1ms）
  篩選 meta_key='_price'（<1ms）
```

**推薦的索引：**

```sql
-- 索引 1：post_id + meta_key（最常用查詢）
ALTER TABLE wp_postmeta ADD INDEX idx_post_id_meta_key (post_id, meta_key);

作用：加速「獲取特定文章的特定元數據」查詢
預計改善：-50-200ms（常見查詢）

-- 索引 2：meta_key + meta_value
ALTER TABLE wp_postmeta ADD INDEX idx_meta_key_meta_value (meta_key, meta_value(100));

作用：加速「查找具有特定元數據的所有文章」
預計改善：-30-100ms（搜索查詢）

-- 索引 3：post_type + post_status
ALTER TABLE wp_posts ADD INDEX idx_post_type_status (post_type, post_status);

作用：加速「獲取特定類型和狀態的文章」
預計改善：-20-80ms（列表查詢）
```

**性能對比：**

```
新增文章：變慢 1-5%（索引更新）
查詢文章：變快 50-70%（索引查詢）

由於查詢遠多於新增，整體提升巨大
```

---

### 2️⃣ 執行 OPTIMIZE TABLE

**什麼是 OPTIMIZE TABLE？**

```
數據庫表在重複插入/刪除後，會產生「碎片」：

未優化：
┌─────────────┬──────────┬──────────┐
│ 數據        │ 空白     │ 數據     │
└─────────────┴──────────┴──────────┘

有碎片 → 讀取速度慢

優化後：
┌─────────────┬─────────────┐
│ 數據        │ 數據        │
└─────────────┴─────────────┘

無碎片 → 讀取速度快
```

**OPTIMIZE TABLE 的作用：**

```
1. 重新整理數據（移除碎片）
2. 釋放未使用的磁盤空間
3. 重建索引結構
4. 重置自增計數器
```

**改善效果：**

```
磁盤 I/O 效率：提高 10-30%
查詢速度：改善 5-20%
內存占用：減少 5-10%

預計頁面加載改善：-50-150ms
```

**執行時間：**

```
表大小 < 10MB：< 1 秒
表大小 10-50MB：5-30 秒
表大小 > 50MB：1-5 分鐘

執行時會鎖表，建議在流量低峰時執行
```

---

### 3️⃣ 數據庫查詢優化

**診斷步驟：**

```bash
# 啟用慢查詢日誌
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 0.1;

# 執行網站操作（加載頁面）

# 檢查慢查詢
SELECT * FROM mysql.slow_log;

# 分析執行計劃
EXPLAIN SELECT ...
```

**常見的慢查詢模式：**

```sql
-- ❌ 慢：沒有 WHERE 條件
SELECT * FROM wp_posts;
執行時間：500-2000ms

-- ✅ 快：有索引條件
SELECT * FROM wp_posts WHERE post_type='post' AND post_status='publish';
執行時間：1-10ms

-- ❌ 慢：沒有在 JOIN 上建索引
SELECT * FROM wp_posts p 
JOIN wp_postmeta pm ON p.ID = pm.post_id 
WHERE pm.meta_key = '_price';
執行時間：200-1000ms

-- ✅ 快：在 JOIN 字段上有索引
同上，但 postmeta(post_id) 有索引
執行時間：5-20ms
```

**預計改善：** -100-500ms（取決於查詢複雜度）

---

## 📈 三階段改善預估

```
當前加載時間：2.3-2.8 秒

階段 1：代碼級 + 伺服器級（已完成）
改善：-50-100ms
結果：2.2-2.7 秒

階段 2：WordPress 核心優化
改善：-50-150ms
結果：2.0-2.5 秒

階段 3：數據庫優化
改善：-150-500ms
結果：1.5-2.0 秒

最終目標：1.3-1.8 秒 ✅
```

---

## ⚠️ 風險評估

### WordPress 核心優化（風險等級：低）
```
✅ 優點：
   - 完全可逆（改回默認值即可）
   - 無數據丟失風險
   - 改變最多影響編輯體驗

⚠️ 缺點：
   - 自動保存間隔變長
   - 修訂版本可能不夠完整

推薦：安全執行，可先執行此優化
```

### 數據庫優化（風險等級：中）
```
✅ 優點：
   - 大幅改善查詢性能
   - 可透過備份恢復

⚠️ 缺點：
   - 執行時會短時間鎖表
   - 需要完整備份
   - 如果索引設計錯誤，可能變慢

推薦：備份後執行，或在流量低峰時執行
```

---

## 🎯 建議執行順序

### 優先級 1：立即執行（低風險）
```
1. AUTOSAVE_INTERVAL = 300（-30-100ms）
2. WP_POST_REVISIONS = 3（-20-50ms）
3. EMPTY_TRASH_DAYS = 7（-10-30ms）

預計改善：-60-180ms
時間：10 分鐘
風險：低
```

### 優先級 2：若不足，執行（中風險）
```
1. 完整備份數據庫
2. 添加 4 個關鍵索引
3. 執行 OPTIMIZE TABLE

預計改善：-150-500ms
時間：30 分鐘
風險：中（有備份保險）
```

### 優先級 3：最終優化（高複雜度）
```
1. 運行慢查詢診斷
2. 分析 EXPLAIN 執行計劃
3. 優化特定查詢

預計改善：-100-300ms
時間：1-2 小時
風險：需要技術深度
```

---

## 📊 預期加載時間目標

```
初始：2.3-2.8 秒
目標：1.3 秒以下

分解：
- HTML 傳輸：0.2-0.3 秒
- DNS 解析：0.05-0.1 秒
- SSL 握手：0.05-0.1 秒
- PHP 執行：0.5-0.8 秒（可優化）
- 數據庫查詢：0.3-0.5 秒（可優化）
- 資源載入：0.2-0.3 秒
- 渲染：0.1-0.2 秒

通過優化 PHP 執行和數據庫查詢，可達成目標
```

---

## ✅ 執行清單

### WordPress 核心優化（推薦立即執行）
- [ ] 備份 wp-config.php
- [ ] 添加 AUTOSAVE_INTERVAL=300
- [ ] 添加 WP_POST_REVISIONS=3
- [ ] 添加 EMPTY_TRASH_DAYS=7
- [ ] 重啟 PHP-FPM
- [ ] 測試頁面加載時間

### 數據庫優化（若第一階段不足）
- [ ] 完整備份數據庫
- [ ] 添加 4 個關鍵索引
- [ ] 執行 OPTIMIZE TABLE
- [ ] 驗證索引效果
- [ ] 測試頁面加載時間

---

**總結：通過分階段優化，可預期達成 1.3 秒加載時間目標**
